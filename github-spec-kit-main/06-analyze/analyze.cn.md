---
description: 在任务生成后，对 spec.md、plan.md 和 tasks.md 执行非破坏性的跨工件一致性和质量分析。
scripts:
  sh: scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks
  ps: scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks
---

## 用户输入```text
$ARGUMENTS
```在继续之前，你**必须**考虑用户输入（如果非空）。

## 目标

在实施之前，识别三个核心文档（`spec.md`、`plan.md`、`tasks.md`）中存在的不一致性、重复性、歧义和未明确项。此命令**必须**仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 之后运行。

## 操作约束

**严格只读**：不要修改任何文件。输出结构化的分析报告。提供可选的补救计划（用户必须明确批准，然后才能手动调用任何后续编辑命令）。

**章程权威**：项目章程（`/memory/constitution.md`）在此分析范围内是**不可协商**的。章程冲突自动视为 CRITICAL（严重）级别，需要调整 spec、plan 或 tasks——而不是淡化、重新解释或默默忽略该原则。如果原则本身需要更改，必须在 `/speckit.analyze` 之外进行单独、明确的章程更新。

## 执行步骤

### 1. 初始化分析上下文

从 repo 根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

如果缺少任何必需文件，则中止并显示错误消息（指示用户运行缺失的先决命令）。
对于参数中的单引号，如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或尽可能使用双引号："I'm Groot"）。

### 2. 加载文档（渐进式披露）

仅从每个文档加载最小必要的上下文：

**从 spec.md：**

- 概述/背景
- 功能需求
- 非功能需求
- 用户故事
- 边缘情况（如果存在）

**从 plan.md：**

- 架构/技术栈选择
- 数据模型引用
- 阶段
- 技术约束

**从 tasks.md：**

- 任务 ID
- 描述
- 阶段分组
- 并行标记 [P]
- 引用的文件路径

**从章程：**

- 加载 `/memory/constitution.md` 以进行原则验证

### 3. 构建语义模型

创建内部表示（输出中不包含原始文档）：

- **需求清单**：每个功能和非功能需求及其稳定键（基于祈使短语推导 slug；例如 "User can upload file" → `user-can-upload-file`）
- **用户故事/动作清单**：具有验收标准的离散用户动作
- **任务覆盖映射**：将每个任务映射到一个或多个需求或故事（通过关键词/显式引用模式如 ID 或关键短语推断）
- **章程规则集**：提取原则名称和 MUST/SHOULD 规范性声明

### 4. 检测轮次（Token 高效分析）

关注高信号发现。限制总发现数为 50 条；将其余部分汇总到溢出摘要中。

#### A. 重复检测

- 识别近似重复的需求
- 标记质量较低的表述以进行合并

#### B. 歧义检测

- 标记缺乏可衡量标准的模糊形容词（fast, scalable, secure, intuitive, robust）
- 标记未解决的占位符（TODO, TKTK, ???, `<placeholder>` 等）

#### C. 规格不足

- 包含动词但缺少对象或可衡量结果的需求
- 缺少验收标准对齐的用户故事
- 引用了 spec/plan 中未定义的文件或组件的任务

#### D. 章程一致性

- 任何与 MUST 原则冲突的需求或计划元素
- 缺少章程规定的章节或质量门

#### E. 覆盖缺口

- 零关联任务的需求
- 无映射需求/故事的任务
- 未在任务中体现的非功能需求（例如性能、安全性）

#### F. 不一致性

- 术语漂移（同一概念在不同文件中命名不同）
- plan 中引用但 spec 中缺失的数据实体（反之亦然）
- 任务排序矛盾（例如，集成任务位于基础设置任务之前，且无依赖说明）
- 需求冲突（例如，一个要求 Next.js，而另一个指定 Vue）

### 5. 严重性分配

使用此启发式方法对发现进行优先级排序：

- **CRITICAL**：违反章程 MUST，缺少核心 spec 文档，或零覆盖的需求阻碍了基线功能
- **HIGH**：重复或冲突的需求，模糊的安全/性能属性，不可测试的验收标准
- **MEDIUM**：术语漂移，缺少非功能任务覆盖，规格不足的边缘情况
- **LOW**：风格/措辞改进，不影响执行顺序的次要冗余

### 6. 生成精简分析报告

输出 Markdown 报告（不写入文件），结构如下：

## 规格分析报告

| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |
|----|----------|----------|-------------|---------|----------------|
| A1 | Duplication | HIGH | spec.md:L120-134 | 两个相似的需求 ... | 合并表述；保留更清晰的版本 |

（每个发现添加一行；生成以类别首字母为前缀的稳定 ID。）

**覆盖摘要表：**

| 需求键 | 有任务? | 任务 ID | 备注 |
|-----------------|-----------|----------|-------|

**章程一致性问题：**（如有）

**未映射任务：**（如有）

**指标：**

- 需求总数
- 任务总数
- 覆盖率 %（需求拥有 >=1 个任务）
- 歧义数量
- 重复数量
- 严重问题数量

### 7. 提供后续行动

在报告末尾，输出一个简洁的“后续行动”块：

- 如果存在 CRITICAL 问题：建议在 `/speckit.implement` 之前解决
- 如果仅有 LOW/MEDIUM：用户可以继续，但提供改进建议
- 提供明确的命令建议：例如，“运行 /speckit.specify 进行细化”，“运行 /speckit.plan 调整架构”，“手动编辑 tasks.md 为 'performance-metrics' 添加覆盖”

### 8. 提供补救

询问用户：“您希望我为排名前 N 的问题建议具体的补救编辑吗？”（不要自动应用它们。）

## 操作原则

### 上下文效率

- **最小高信号 Token**：关注可操作的发现，而非详尽的文档
- **渐进式披露**：增量加载文档；不要将所有内容转储到分析中
- **Token 高效输出**：发现表限制为 50 行；汇总溢出部分
- **确定性结果**：在无变更的情况下重新运行应产生一致的 ID 和计数

### 分析指南

- **永不修改文件**（这是只读分析）
- **永不臆造缺失章节**（如果缺失，请准确报告）
- **优先处理章程违规**（这些总是 CRITICAL）
- **使用示例而非详尽规则**（引用具体实例，而非通用模式）
- **优雅地报告零问题**（发出包含覆盖统计信息的成功报告）

## 上下文

{ARGS}