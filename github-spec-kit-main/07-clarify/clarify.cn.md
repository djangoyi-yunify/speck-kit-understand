---
description: 通过提出最多 5 个高度针对性的澄清问题，识别当前功能规范中定义不明确的区域，并将答案写回规范中。
handoffs: 
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 为规范创建计划。我正在使用...构建
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## 用户输入```text
$ARGUMENTS
```在继续之前，你**必须**考虑用户输入（如果不为空）。

## 大纲

目标：检测并减少当前 Feature 规格说明书中的歧义或缺失的决策点，并将澄清内容直接记录在 Spec 文件中。

注意：此澄清 Workflow 预期在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示跳过澄清（例如探索性 Spike），你可以继续，但必须警告下游返工风险增加。

执行步骤：

1. 从 Repo 根目录运行 `{SCRIPT}` 一次（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON payload 字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （可选捕获 `IMPL_PLAN`、`TASKS` 用于未来的链式 Flow。）
   - 如果 JSON 解析失败，中止并指示用户重新运行 `/speckit.specify` 或验证 Feature 分支环境。
   - 对于参数中的单引号，如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或尽可能使用双引号："I'm Groot"）。

2. 加载当前 Spec 文件。使用此分类法执行结构化的歧义与覆盖范围扫描。对于每个类别，标记状态：Clear / Partial / Missing。生成用于优先级排序的内部覆盖图（除非不提问，否则不输出原始图）。

   功能范围与行为：
   - 核心用户目标与成功标准
   - 明确的范围外声明
   - 用户角色/画像区分

   领域与数据模型：
   - 实体、属性、关系
   - 标识与唯一性规则
   - 生命周期/状态转换
   - 数据量/规模假设

   交互与 UX Flow：
   - 关键用户旅程/序列
   - 错误/空/加载状态
   - 无障碍或本地化说明

   非功能性质量属性：
   - 性能（延迟、吞吐量目标）
   - 可扩展性（水平/垂直、限制）
   - 可靠性与可用性（正常运行时间、恢复预期）
   - 可观测性（日志、指标、追踪信号）
   - 安全与隐私（AuthN/Z、数据保护、威胁假设）
   - 合规/监管约束（如有）

   集成与外部依赖：
   - 外部服务/API 及其故障模式
   - 数据导入/导出格式
   - 协议/版本假设

   边缘情况与故障处理：
   - 负面场景
   - 速率限制/节流
   - 冲突解决（例如并发编辑）

   约束与权衡：
   - 技术约束（语言、存储、托管）
   - 明确的权衡或已拒绝的替代方案

   术语与一致性：
   - 规范术语表词汇
   - 避免使用的同义词/已弃用术语

   完成信号：
   - 验收标准可测试性
   - 可度量的 Definition of Done 风格指标

   杂项/占位符：
   - TODO 标记/未解决的决定
   - 缺乏量化的模糊形容词（如“健壮”、“直观”）

   对于每个标记为 Partial 或 Missing 状态的类别，添加一个候选问题机会，除非：
   - 澄清不会实质性改变实现或验证策略
   - 信息更适合推迟到规划阶段（内部记录）

3. （内部）生成优先排序的候选澄清问题队列（最多 5 个）。不要一次性全部输出。应用以下约束：
    - 整个会话最多 10 个问题。
    - 每个问题必须能通过以下任一方式回答：
       - 简短的多选题（2-5 个不同、互斥的选项），或
       - 单词/短语回答（明确限制：“回答字数 <=5”）。
    - 仅包含那些答案会实质性影响架构、数据建模、任务分解、测试设计、UX 行为、运维准备或合规验证的问题。
    - 确保类别覆盖平衡：尝试优先覆盖影响最大的未解决类别；当单个高影响区域（如安全态势）未解决时，避免问两个低影响问题。
    - 排除已回答的问题、琐碎的风格偏好或计划级执行细节（除非阻碍正确性）。
    - 倾向于能减少下游返工风险或防止验收测试不一致的澄清。
    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。

4. 顺序提问循环（交互式）：
    - 一次只展示一个问题。
    - 对于多选题：
       - **分析所有选项**并根据以下因素确定**最合适的选项**：
          - 项目类型的最佳实践
          - 类似实现中的常见模式
          - 风险降低（安全性、性能、可维护性）
          - 与 Spec 中可见的任何明确项目目标或约束保持一致
       - 在顶部显著展示你的**推荐选项**，并附上清晰的理由（1-2 句话解释为什么这是最佳选择）。
       - 格式为：`**推荐：** 选项 [X] - <理由>`
       - 然后将所有选项渲染为 Markdown 表格：

       | 选项 | 描述 |
       |--------|-------------|
       | A | <选项 A 描述> |
       | B | <选项 B 描述> |
       | C | <选项 C 描述> （根据需要添加 D/E，最多 5 个） |
       | Short | 提供不同的简短回答（<=5 个字）（仅在适合自由形式替代方案时包含） |

       - 表格后添加：`你可以回复选项字母（例如 "A"），说 "yes" 或 "recommended" 接受推荐，或提供你自己的简短回答。`
    - 对于简答题风格（无有意义的离散选项）：
       - 根据最佳实践和上下文提供你的**建议回答**。
       - 格式为：`**建议：** <你提议的回答> - <简短理由>`
       - 然后输出：`格式：简短回答（<=5 个字）。你可以说 "yes" 或 "suggested" 接受建议，或提供你自己的回答。`
    - 用户回答后：
       - 如果用户回复 "yes"、"recommended" 或 "suggested"，使用你之前陈述的推荐/建议作为答案。
       - 否则，验证答案是否映射到一个选项或符合 <=5 个字的约束。
       - 如果有歧义，要求快速澄清（计数仍属于同一问题；不推进）。
       - 一旦满意，将其记录在工作记忆中（暂不写入磁盘）并移至下一个排队问题。
    - 停止进一步提问当：
       - 所有关键歧义已早期解决（剩余排队项变得不必要），或
       - 用户发出完成信号（"done"、"good"、"no more"），或
       - 达到 5 个已问问题。
    - 切勿提前透露未来排队的问题。
    - 如果开始时不存在有效问题，立即报告未发现关键歧义。

5. 每次接受回答后的集成（增量更新方法）：
    - 在内存中维护 Spec 表示（开始时加载一次）以及原始文件内容。
    - 对于本次会话中的第一个集成答案：
       - 确保存在 `## Clarifications` 部分（如果缺失，根据 Spec 模板在最高层级的上下文/概述部分之后创建）。
       - 在其下，为今天创建（如果不存在）一个 `### Session YYYY-MM-DD` 子标题。
    - 接受后立即追加一行要点：`- Q: <问题> → A: <最终答案>`。
    - 然后立即将澄清应用到最合适的部分：
       - 功能歧义 → 更新或在功能需求中添加要点。
       - 用户交互/角色区分 → 更新用户故事或角色子部分（如果存在），包含澄清的角色、约束或场景。
       - 数据形状/实体 → 更新数据模型（添加字段、类型、关系）保持顺序；简洁地记录添加的约束。
       - 非功能性约束 → 在非功能性/质量属性部分添加/修改可度量标准（将模糊形容词转换为指标或明确目标）。
       - 边缘情况/负面流程 → 在边缘情况/错误处理下添加新要点（或如果模板提供了占位符则创建此类子部分）。
       - 术语冲突 → 规范 Spec 中的术语；仅在必要时保留原词，并添加 `(formerly referred to as "X")` 一次。
    - 如果澄清使早期模糊陈述无效，替换该陈述而不是复制；不留过时的矛盾文本。
    - 每次集成后保存 Spec 文件以最小化上下文丢失风险（原子覆盖）。
    - 保留格式：不要重新排序无关部分；保持标题层次完整。
    - 保持每个插入的澄清最小且可测试（避免叙述性偏离）。

6. 验证（每次写入后执行加最终检查）：
   - Clarifications 会话中每个接受的答案恰好包含一个要点（无重复）。
   - 总提问（已接受）数 ≤ 5。
   - 更新的部分不包含新答案旨在解决的残留模糊占位符。
   - 不保留矛盾的早期陈述（扫描现已无效的替代选择并移除）。
   - Markdown 结构有效；仅允许的新标题：`## Clarifications`、`### Session YYYY-MM-DD`。
   - 术语一致性：所有更新部分使用相同的规范术语。

7. 将更新后的 Spec 写回 `FEATURE_SPEC`。

8. 报告完成（提问循环结束或提前终止后）：
   - 提问并回答的数量。
   - 更新后的 Spec 路径。
   - 涉及的部分（列出名称）。
   - 覆盖率摘要表，列出每个分类法类别及其状态：Resolved（原为 Partial/Missing 并已解决）、Deferred（超出问题配额或更适合规划）、Clear（已足够）、Outstanding（仍为 Partial/Missing 但影响低）。
   - 如果存在任何 Outstanding 或 Deferred，建议是继续执行 `/speckit.plan` 还是稍后计划后再次运行 `/speckit.clarify`。
   - 建议的下一个命令。

行为规则：

- 如果未发现实质性歧义（或所有潜在问题均为低影响），回复：“No critical ambiguities detected worth formal clarification.” 并建议继续。
- 如果 Spec 文件缺失，指示用户先运行 `/speckit.specify`（此处不创建新 Spec）。
- 切勿超过 5 个总提问数（单个问题的澄清重试不计为新问题）。
- 避免推测性技术栈问题，除非缺失阻碍了功能清晰度。
- 尊重用户提前终止信号（"stop"、"done"、"proceed"）。
- 如果因全覆盖而未提问，输出紧凑的覆盖率摘要（所有类别 Clear）然后建议推进。
- 如果达到配额但仍有未解决的高影响类别，在 Deferred 下明确标记并附理由。

优先级排序上下文：{ARGS}